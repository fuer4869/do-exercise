---
title: leetcode刷题笔记(一)
date: 2019-10-22 11:12:19
tags: 算法, leetcode
category: 笔记
---

======================

### 题一
=========================================================================================================================

在一个 8x8 的棋盘上，放置着若干「黑皇后」和一个「白国王」。

「黑皇后」在棋盘上的位置分布用整数坐标数组 queens
表示，「白国王」的坐标用数组 king 表示。

「黑皇后」的行棋规定是：横、直、斜都可以走，步数不受限制，但是，不能越子行棋。

请你返回可以直接攻击到「白国王」的所有「黑皇后」的坐标（任意顺序）。

![](./leetcode第一周刷题总结%20_%20飞奔的蜗牛个人博客_files/untitled-diagram.jpg)

-   输入：queens = \[\[0,1\],\[1,0\],\[4,0\],\[0,4\],\[3,3\],\[2,4\]\],
    king = \[0,0\]

-   输出：\[\[0,1\],\[1,0\],\[3,3\]\]

**解释：**

-   \[0,1\] 的皇后可以攻击到国王，因为他们在同一行上。
-   \[1,0\] 的皇后可以攻击到国王，因为他们在同一列上。
-   \[3,3\] 的皇后可以攻击到国王，因为他们在同一条对角线上。
-   \[0,4\] 的皇后无法攻击到国王，因为她被位于 \[0,1\] 的皇后挡住了。
-   \[4,0\] 的皇后无法攻击到国王，因为她被位于 \[1,0\] 的皇后挡住了。
-   \[2,4\] 的皇后无法攻击到国王，因为她和国王不在同一行/列/对角线上。

**提示**

-   1 \<= queens.length \<= 63
-   queens\[0\].length == 2
-   0 \<= queens\[i\]\[j\] \< 8
-   king.length == 2
-   0 \<= king\[0\], king\[1\] \< 8
-   一个棋盘格上最多只能放置一枚棋子。

#### 审题

从解释和提示中我们可以得到两条重要的线索：

-   king的取值范围：0 \<= x \< 8
-   皇后只能走一个方向，不能绕路走。要么走横线，要么走竖线，要么走对角线。
-   只需找到离king最近的能攻击到king的皇后

### 解题思路

无需考虑king在棋盘的什么位置，直接以king为中心进行八方向探索，直到找到最近的皇后。我们可以创建一个含有八个不同方向的坐标，如（1，0）就是往右一格一格进行搜索。

(一开始浪费时间在考虑king的位置上了，后来一想直接限定king的探索范围就好了)

```
class Solution:                
    def queensAttacktheKing(self, queens: List[List[int]], king: List[int]) -> List[List[int]]:  
         # 上    右上   右    右下    下    左下    左     左上    
         direction = [[-1,0],[-1,1],[0,1],[1,1],[1,0],[1,-1],[0,-1],[-1,-1]]  
         queens = {(x,y) for x,y in queens}  
         res = []               
         # 八方向查找           
         for a,b in direction:  
         # 找到皇后后，x,   
         y回到初始位置继续往另外个方向探索  
         x = king[0]        
         y = king[1]        

         while 0 <= x < 8 and 0 <= y < 8:  
         x += a         
         y += b         
         # 这里本身是想对queens做for循环遍历来做比对的，因为这里本身已经在for循环中  
         了，会造成多余的操作。后来借鉴了别人的代码，把queens改为字典了。   

         if(x,y) in queens:  
             res.append([x,y])  
             break      
        return res             
```
      执行用时 :                     
      48 ms                          
      内存消耗 :                     
      14 MB                  

#### 总结

解题思路基本上有了，但是花了很多时间在处理for循环上始终找不到最优的方式去匹配坐标。学到了可以通过字典的形式来做匹配，既方便还不用再创建个循环。
